---
title: "Examen"
format: html
editor: visual
self-contained: true
---

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(tidymodels)
library(lubridate)
```

```{r, message = FALSE}
hoteles_df <- read_csv("./hoteles-entrena.csv", show_col_types = FALSE) |>
  mutate(children = ifelse(children == "children", 1, 0)) |>
  mutate(children = as.factor(children))
colnames(hoteles_df)[8] <- "country_code"
```

Y vemos el desbalance de clases:

```{r}
nrow(hoteles_df)
hoteles_df |> count(children) |> 
  mutate(pct = 100 * n / sum(n)) |> 
  mutate(pct = round(pct, 2))
```

Obtenemos un dataset con los códigos de los países

```{r message=FALSE, warning=FALSE}
library(RCurl)
countries_link <- getURL("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv")
countries <- read.csv(text=countries_link)
countries <- countries |> select("alpha.3", "region")
colnames(countries)[1] <- "country_code"
countries <- countries |> 
  mutate(region = ifelse(region == "", "Antartica", region))
```

Se usará la variable country pero hay que hacer una ingeniería de variables

```{r}
country_mode <- which.max(table(hoteles_df$country_code))
hoteles_df <- hoteles_df |> 
  mutate(country_code = ifelse(country_code == "NULL", names(country_mode), country_code)) |>
  mutate(country_code = ifelse(country_code == "CN", "CHN", country_code))
```

Hacemos un join de los códigos de país para obtener su región

```{r}
hoteles_df <- left_join(x=hoteles_df, y=countries, by="country_code")
hoteles_df <- hoteles_df |>
  mutate(region = ifelse(country_code == "TMP", "Asia", region))
hoteles_df <- hoteles_df |> mutate(region = as.factor(region))
```

Preparamos receta

```{r}
receta_hoteles <- recipe(children ~ 
           hotel + lead_time + stays_in_weekend_nights + 
           stays_in_week_nights + adults + meal +
           region + market_segment + distribution_channel +
           reserved_room_type + agent + customer_type +
           average_daily_rate + required_car_parking_spaces + 
           total_of_special_requests + arrival_date, 
           data = hoteles_df) |> 
  step_mutate(hotel = ifelse(hotel == "Resort_Hotel", 1, 0)) |>
  step_cut(stays_in_weekend_nights, breaks = c(0, 1, 2, 3, 4, 5), 
           include_outside_range = TRUE) |>
  step_cut(stays_in_week_nights, breaks = c(0, 1, 2, 3, 4, 5), 
           include_outside_range = TRUE) |>
  step_mutate(agent = ifelse(is.null(agent), 1, 0)) |>
  step_mutate(parking = ifelse(required_car_parking_spaces == "parking", 1, 0)) |>
  step_mutate(month = month(ymd(arrival_date))) |>
  step_relevel(meal, ref_level = "Undefined", skip=TRUE) |>
  step_relevel(market_segment, ref_level = "Direct", skip=TRUE) |>
  step_relevel(distribution_channel, ref_level = "Undefined", skip = TRUE) |>
  step_relevel(region, ref_level = "Europe", skip = TRUE) |>
  step_dummy(meal,
             market_segment,
             distribution_channel,
             reserved_room_type,
             stays_in_weekend_nights,
             stays_in_week_nights,
             customer_type,
             region) |>
  step_select(-required_car_parking_spaces, skip=TRUE) |>
  step_select(-arrival_date, skip = TRUE) |>
  step_interact(terms = ~ hotel:starts_with("reserved_room_type")) |>
  step_interact(terms = ~ hotel:starts_with("market_segment")) |>
  step_interact(terms = ~ hotel:starts_with("customer_type")) |>
  step_interact(terms = ~ adults:starts_with("market_segment")) |>
  step_interact(terms = ~ adults:starts_with("reserved_room_type")) |>
  step_interact(terms = ~ adults:starts_with("stays_in_weekend_nights")) |>
  step_interact(terms = ~ adults:starts_with("customer_type")) |>
  step_interact(terms = ~ adults:starts_with("region")) |>
  step_interact(terms = ~ adults:starts_with("meal")) |>
  step_interact(terms = ~ lead_time:starts_with("reserved_room_type")) |>
  step_interact(terms = ~ lead_time:starts_with("region")) |>
  step_interact(terms = ~ lead_time:starts_with("customer_type")) |>
  step_interact(terms = ~ lead_time:starts_with("market_segment")) |>
  step_interact(terms = ~ total_of_special_requests:starts_with("meal")) |>
  step_interact(terms = ~ total_of_special_requests:starts_with("reserved_room_type")) |>
  step_interact(terms = ~ total_of_special_requests:starts_with("customer_type")) |>
  step_interact(terms = ~ average_daily_rate:starts_with("adults")) |>
  step_interact(terms = ~ average_daily_rate:starts_with("reserved_room_type")) |>
  step_interact(terms = ~ average_daily_rate:starts_with("customer_type")) |>
  step_interact(terms = ~ average_daily_rate:starts_with("region")) |>
  step_interact(terms = ~ average_daily_rate:starts_with("meal"))
```

```{r}
receta_normalized <-
  receta_hoteles |> step_normalize(all_predictors())
```

```{r}
receta_hoteles_prep <- prep(receta_hoteles, verbose = TRUE)
hoteles_tbl <- juice(receta_hoteles_prep)
dim(hoteles_tbl)
```

```{r}
receta_hoteles_prep_norm <- prep(receta_normalized, verbose = TRUE)
hoteles_tbl_norm <- juice(receta_hoteles_prep_norm)
dim(hoteles_tbl_norm)
```

Asignamos pesos por clase

```{r}
fraction_0 <- rep(1-sum(hoteles_df$children == 0)/nrow(hoteles_df), sum(hoteles_df$children==0))
fraction_1 <- rep(1-sum(hoteles_df$children == 1)/nrow(hoteles_df), sum(hoteles_df$children==1))

# assign that value to a "weights" vector
weights_children <- numeric(nrow(hoteles_df))
weights_children[hoteles_df$children == 0] <- fraction_0
weights_children[hoteles_df$children == 1] <- fraction_1
```

### Regresión logística regularizada

```{r}
modelo_logistico <- 
  logistic_reg(mixture = tune(), penalty = tune()) |> 
  set_args(lambda.min_ratio = 0, weights = weights_children) |> 
  set_engine("glmnet")

flujo_hoteles <- workflow() |> 
  add_recipe(receta_hoteles) |> 
  add_model(modelo_logistico)
```

Y ahora ajustamos todos los modelos. Evaluamos con la pérdida logarítmica:

```{r}
particion_vc <- vfold_cv(hoteles_df, v = 15)
mis_metricas <- metric_set(mn_log_loss)

# hacemos un grid de valores de mezcla y penalización
params <- parameters(penalty(range = c(-5,5), trans = log10_trans()),
                            mixture(range = c(0,1)))

grid <- grid_regular(params, levels = c(penalty = 50, mixture = 10))

eval_tbl <- tune_grid(flujo_hoteles,
                      resamples = particion_vc,
                      grid = grid,
                      metrics = mis_metricas) 

ajustes_tbl <- eval_tbl |>
  unnest(cols = c(.metrics)) |> 
  select(id, mixture, penalty, .metric, .estimate)
ajustes_tbl
```

```{r}
ggplot(ajustes_tbl, aes(x = penalty, y = .estimate, colour = mixture, group = mixture)) +
  geom_point() + geom_line() + scale_x_log10()
```

Finalmente, seleccionamos el mejor modelo:

```{r}
mejor_modelo <- select_best(eval_tbl)
mejor_modelo
```

```{r}
modelo_final <- finalize_workflow(flujo_hoteles, mejor_modelo) |> 
  fit(hoteles_df)
```

### Análisis de las probabilidades de compra

```{r, message = FALSE}
hoteles_test <- read_csv("./hoteles-prueba.csv", show_col_types = FALSE)
colnames(hoteles_test)[8] <- "country_code"
hoteles_test <- hoteles_test |> 
  mutate(country_code = ifelse(country_code == "NULL", names(country_mode), country_code)) |>
  mutate(country_code = ifelse(country_code == "CN", "CHN", country_code))
```

```{r}
hoteles_test <- left_join(x=hoteles_test, y=countries, by="country_code")
hoteles_test <- hoteles_test |>
  mutate(region = ifelse(country_code == "TMP", "Asia", region))
hoteles_test <- hoteles_test |> mutate(region = as.factor(region))
hoteles_test <- hoteles_test |> arrange(id)
```

```{r}
pred_probas <- predict(modelo_final, hoteles_test, type="prob") 
head(pred_probas)
```

```{r}
res <- bind_cols(id = seq(1:nrow(hoteles_test)), prob = pred_probas$.pred_1)
write.csv(res,"res.csv", row.names = FALSE)
```

```{r}
pred_probas <- pred_probas |> 
  bind_cols(hoteles_test)
head(pred_probas |> select(.pred_1, .pred_0))
```
